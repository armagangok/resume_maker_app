// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'exceptions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MyException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCachedException,
    required TResult Function() unknownLocalException,
    required TResult Function() deletingMyException,
    required TResult Function() unknownRemoteException,
    required TResult Function() noInternetException,
    required TResult Function() forbiddenMyException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noCachedException,
    TResult? Function()? unknownLocalException,
    TResult? Function()? deletingMyException,
    TResult? Function()? unknownRemoteException,
    TResult? Function()? noInternetException,
    TResult? Function()? forbiddenMyException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCachedException,
    TResult Function()? unknownLocalException,
    TResult Function()? deletingMyException,
    TResult Function()? unknownRemoteException,
    TResult Function()? noInternetException,
    TResult Function()? forbiddenMyException,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCachedException value) noCachedException,
    required TResult Function(UnknownLocalException value)
        unknownLocalException,
    required TResult Function(DeletingMyException value) deletingMyException,
    required TResult Function(UnknownRemoteException value)
        unknownRemoteException,
    required TResult Function(NoInternetException value) noInternetException,
    required TResult Function(ForbiddenMyException value) forbiddenMyException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoCachedException value)? noCachedException,
    TResult? Function(UnknownLocalException value)? unknownLocalException,
    TResult? Function(DeletingMyException value)? deletingMyException,
    TResult? Function(UnknownRemoteException value)? unknownRemoteException,
    TResult? Function(NoInternetException value)? noInternetException,
    TResult? Function(ForbiddenMyException value)? forbiddenMyException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCachedException value)? noCachedException,
    TResult Function(UnknownLocalException value)? unknownLocalException,
    TResult Function(DeletingMyException value)? deletingMyException,
    TResult Function(UnknownRemoteException value)? unknownRemoteException,
    TResult Function(NoInternetException value)? noInternetException,
    TResult Function(ForbiddenMyException value)? forbiddenMyException,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyExceptionCopyWith<$Res> {
  factory $MyExceptionCopyWith(
          CustomException value, $Res Function(CustomException) then) =
      _$MyExceptionCopyWithImpl<$Res, CustomException>;
}

/// @nodoc
class _$MyExceptionCopyWithImpl<$Res, $Val extends CustomException>
    implements $MyExceptionCopyWith<$Res> {
  _$MyExceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NoCachedExceptionCopyWith<$Res> {
  factory _$$NoCachedExceptionCopyWith(
          _$NoCachedException value, $Res Function(_$NoCachedException) then) =
      __$$NoCachedExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoCachedExceptionCopyWithImpl<$Res>
    extends _$MyExceptionCopyWithImpl<$Res, _$NoCachedException>
    implements _$$NoCachedExceptionCopyWith<$Res> {
  __$$NoCachedExceptionCopyWithImpl(
      _$NoCachedException _value, $Res Function(_$NoCachedException) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoCachedException implements NoCachedException {
  const _$NoCachedException();

  @override
  String toString() {
    return 'MyException.noCachedException()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoCachedException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCachedException,
    required TResult Function() unknownLocalException,
    required TResult Function() deletingMyException,
    required TResult Function() unknownRemoteException,
    required TResult Function() noInternetException,
    required TResult Function() forbiddenMyException,
  }) {
    return noCachedException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noCachedException,
    TResult? Function()? unknownLocalException,
    TResult? Function()? deletingMyException,
    TResult? Function()? unknownRemoteException,
    TResult? Function()? noInternetException,
    TResult? Function()? forbiddenMyException,
  }) {
    return noCachedException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCachedException,
    TResult Function()? unknownLocalException,
    TResult Function()? deletingMyException,
    TResult Function()? unknownRemoteException,
    TResult Function()? noInternetException,
    TResult Function()? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (noCachedException != null) {
      return noCachedException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCachedException value) noCachedException,
    required TResult Function(UnknownLocalException value)
        unknownLocalException,
    required TResult Function(DeletingMyException value) deletingMyException,
    required TResult Function(UnknownRemoteException value)
        unknownRemoteException,
    required TResult Function(NoInternetException value) noInternetException,
    required TResult Function(ForbiddenMyException value) forbiddenMyException,
  }) {
    return noCachedException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoCachedException value)? noCachedException,
    TResult? Function(UnknownLocalException value)? unknownLocalException,
    TResult? Function(DeletingMyException value)? deletingMyException,
    TResult? Function(UnknownRemoteException value)? unknownRemoteException,
    TResult? Function(NoInternetException value)? noInternetException,
    TResult? Function(ForbiddenMyException value)? forbiddenMyException,
  }) {
    return noCachedException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCachedException value)? noCachedException,
    TResult Function(UnknownLocalException value)? unknownLocalException,
    TResult Function(DeletingMyException value)? deletingMyException,
    TResult Function(UnknownRemoteException value)? unknownRemoteException,
    TResult Function(NoInternetException value)? noInternetException,
    TResult Function(ForbiddenMyException value)? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (noCachedException != null) {
      return noCachedException(this);
    }
    return orElse();
  }
}

abstract class NoCachedException implements CustomException {
  const factory NoCachedException() = _$NoCachedException;
}

/// @nodoc
abstract class _$$UnknownLocalExceptionCopyWith<$Res> {
  factory _$$UnknownLocalExceptionCopyWith(_$UnknownLocalException value,
          $Res Function(_$UnknownLocalException) then) =
      __$$UnknownLocalExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownLocalExceptionCopyWithImpl<$Res>
    extends _$MyExceptionCopyWithImpl<$Res, _$UnknownLocalException>
    implements _$$UnknownLocalExceptionCopyWith<$Res> {
  __$$UnknownLocalExceptionCopyWithImpl(_$UnknownLocalException _value,
      $Res Function(_$UnknownLocalException) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnknownLocalException implements UnknownLocalException {
  const _$UnknownLocalException();

  @override
  String toString() {
    return 'MyException.unknownLocalException()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnknownLocalException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCachedException,
    required TResult Function() unknownLocalException,
    required TResult Function() deletingMyException,
    required TResult Function() unknownRemoteException,
    required TResult Function() noInternetException,
    required TResult Function() forbiddenMyException,
  }) {
    return unknownLocalException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noCachedException,
    TResult? Function()? unknownLocalException,
    TResult? Function()? deletingMyException,
    TResult? Function()? unknownRemoteException,
    TResult? Function()? noInternetException,
    TResult? Function()? forbiddenMyException,
  }) {
    return unknownLocalException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCachedException,
    TResult Function()? unknownLocalException,
    TResult Function()? deletingMyException,
    TResult Function()? unknownRemoteException,
    TResult Function()? noInternetException,
    TResult Function()? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (unknownLocalException != null) {
      return unknownLocalException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCachedException value) noCachedException,
    required TResult Function(UnknownLocalException value)
        unknownLocalException,
    required TResult Function(DeletingMyException value) deletingMyException,
    required TResult Function(UnknownRemoteException value)
        unknownRemoteException,
    required TResult Function(NoInternetException value) noInternetException,
    required TResult Function(ForbiddenMyException value) forbiddenMyException,
  }) {
    return unknownLocalException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoCachedException value)? noCachedException,
    TResult? Function(UnknownLocalException value)? unknownLocalException,
    TResult? Function(DeletingMyException value)? deletingMyException,
    TResult? Function(UnknownRemoteException value)? unknownRemoteException,
    TResult? Function(NoInternetException value)? noInternetException,
    TResult? Function(ForbiddenMyException value)? forbiddenMyException,
  }) {
    return unknownLocalException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCachedException value)? noCachedException,
    TResult Function(UnknownLocalException value)? unknownLocalException,
    TResult Function(DeletingMyException value)? deletingMyException,
    TResult Function(UnknownRemoteException value)? unknownRemoteException,
    TResult Function(NoInternetException value)? noInternetException,
    TResult Function(ForbiddenMyException value)? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (unknownLocalException != null) {
      return unknownLocalException(this);
    }
    return orElse();
  }
}

abstract class UnknownLocalException implements CustomException {
  const factory UnknownLocalException() = _$UnknownLocalException;
}

/// @nodoc
abstract class _$$DeletingMyExceptionCopyWith<$Res> {
  factory _$$DeletingMyExceptionCopyWith(_$DeletingMyException value,
          $Res Function(_$DeletingMyException) then) =
      __$$DeletingMyExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DeletingMyExceptionCopyWithImpl<$Res>
    extends _$MyExceptionCopyWithImpl<$Res, _$DeletingMyException>
    implements _$$DeletingMyExceptionCopyWith<$Res> {
  __$$DeletingMyExceptionCopyWithImpl(
      _$DeletingMyException _value, $Res Function(_$DeletingMyException) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DeletingMyException implements DeletingMyException {
  const _$DeletingMyException();

  @override
  String toString() {
    return 'MyException.deletingMyException()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DeletingMyException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCachedException,
    required TResult Function() unknownLocalException,
    required TResult Function() deletingMyException,
    required TResult Function() unknownRemoteException,
    required TResult Function() noInternetException,
    required TResult Function() forbiddenMyException,
  }) {
    return deletingMyException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noCachedException,
    TResult? Function()? unknownLocalException,
    TResult? Function()? deletingMyException,
    TResult? Function()? unknownRemoteException,
    TResult? Function()? noInternetException,
    TResult? Function()? forbiddenMyException,
  }) {
    return deletingMyException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCachedException,
    TResult Function()? unknownLocalException,
    TResult Function()? deletingMyException,
    TResult Function()? unknownRemoteException,
    TResult Function()? noInternetException,
    TResult Function()? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (deletingMyException != null) {
      return deletingMyException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCachedException value) noCachedException,
    required TResult Function(UnknownLocalException value)
        unknownLocalException,
    required TResult Function(DeletingMyException value) deletingMyException,
    required TResult Function(UnknownRemoteException value)
        unknownRemoteException,
    required TResult Function(NoInternetException value) noInternetException,
    required TResult Function(ForbiddenMyException value) forbiddenMyException,
  }) {
    return deletingMyException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoCachedException value)? noCachedException,
    TResult? Function(UnknownLocalException value)? unknownLocalException,
    TResult? Function(DeletingMyException value)? deletingMyException,
    TResult? Function(UnknownRemoteException value)? unknownRemoteException,
    TResult? Function(NoInternetException value)? noInternetException,
    TResult? Function(ForbiddenMyException value)? forbiddenMyException,
  }) {
    return deletingMyException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCachedException value)? noCachedException,
    TResult Function(UnknownLocalException value)? unknownLocalException,
    TResult Function(DeletingMyException value)? deletingMyException,
    TResult Function(UnknownRemoteException value)? unknownRemoteException,
    TResult Function(NoInternetException value)? noInternetException,
    TResult Function(ForbiddenMyException value)? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (deletingMyException != null) {
      return deletingMyException(this);
    }
    return orElse();
  }
}

abstract class DeletingMyException implements CustomException {
  const factory DeletingMyException() = _$DeletingMyException;
}

/// @nodoc
abstract class _$$UnknownRemoteExceptionCopyWith<$Res> {
  factory _$$UnknownRemoteExceptionCopyWith(_$UnknownRemoteException value,
          $Res Function(_$UnknownRemoteException) then) =
      __$$UnknownRemoteExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownRemoteExceptionCopyWithImpl<$Res>
    extends _$MyExceptionCopyWithImpl<$Res, _$UnknownRemoteException>
    implements _$$UnknownRemoteExceptionCopyWith<$Res> {
  __$$UnknownRemoteExceptionCopyWithImpl(_$UnknownRemoteException _value,
      $Res Function(_$UnknownRemoteException) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnknownRemoteException implements UnknownRemoteException {
  const _$UnknownRemoteException();

  @override
  String toString() {
    return 'MyException.unknownRemoteException()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnknownRemoteException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCachedException,
    required TResult Function() unknownLocalException,
    required TResult Function() deletingMyException,
    required TResult Function() unknownRemoteException,
    required TResult Function() noInternetException,
    required TResult Function() forbiddenMyException,
  }) {
    return unknownRemoteException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noCachedException,
    TResult? Function()? unknownLocalException,
    TResult? Function()? deletingMyException,
    TResult? Function()? unknownRemoteException,
    TResult? Function()? noInternetException,
    TResult? Function()? forbiddenMyException,
  }) {
    return unknownRemoteException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCachedException,
    TResult Function()? unknownLocalException,
    TResult Function()? deletingMyException,
    TResult Function()? unknownRemoteException,
    TResult Function()? noInternetException,
    TResult Function()? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (unknownRemoteException != null) {
      return unknownRemoteException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCachedException value) noCachedException,
    required TResult Function(UnknownLocalException value)
        unknownLocalException,
    required TResult Function(DeletingMyException value) deletingMyException,
    required TResult Function(UnknownRemoteException value)
        unknownRemoteException,
    required TResult Function(NoInternetException value) noInternetException,
    required TResult Function(ForbiddenMyException value) forbiddenMyException,
  }) {
    return unknownRemoteException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoCachedException value)? noCachedException,
    TResult? Function(UnknownLocalException value)? unknownLocalException,
    TResult? Function(DeletingMyException value)? deletingMyException,
    TResult? Function(UnknownRemoteException value)? unknownRemoteException,
    TResult? Function(NoInternetException value)? noInternetException,
    TResult? Function(ForbiddenMyException value)? forbiddenMyException,
  }) {
    return unknownRemoteException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCachedException value)? noCachedException,
    TResult Function(UnknownLocalException value)? unknownLocalException,
    TResult Function(DeletingMyException value)? deletingMyException,
    TResult Function(UnknownRemoteException value)? unknownRemoteException,
    TResult Function(NoInternetException value)? noInternetException,
    TResult Function(ForbiddenMyException value)? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (unknownRemoteException != null) {
      return unknownRemoteException(this);
    }
    return orElse();
  }
}

abstract class UnknownRemoteException implements CustomException {
  const factory UnknownRemoteException() = _$UnknownRemoteException;
}

/// @nodoc
abstract class _$$NoInternetExceptionCopyWith<$Res> {
  factory _$$NoInternetExceptionCopyWith(_$NoInternetException value,
          $Res Function(_$NoInternetException) then) =
      __$$NoInternetExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoInternetExceptionCopyWithImpl<$Res>
    extends _$MyExceptionCopyWithImpl<$Res, _$NoInternetException>
    implements _$$NoInternetExceptionCopyWith<$Res> {
  __$$NoInternetExceptionCopyWithImpl(
      _$NoInternetException _value, $Res Function(_$NoInternetException) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoInternetException implements NoInternetException {
  const _$NoInternetException();

  @override
  String toString() {
    return 'MyException.noInternetException()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoInternetException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCachedException,
    required TResult Function() unknownLocalException,
    required TResult Function() deletingMyException,
    required TResult Function() unknownRemoteException,
    required TResult Function() noInternetException,
    required TResult Function() forbiddenMyException,
  }) {
    return noInternetException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noCachedException,
    TResult? Function()? unknownLocalException,
    TResult? Function()? deletingMyException,
    TResult? Function()? unknownRemoteException,
    TResult? Function()? noInternetException,
    TResult? Function()? forbiddenMyException,
  }) {
    return noInternetException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCachedException,
    TResult Function()? unknownLocalException,
    TResult Function()? deletingMyException,
    TResult Function()? unknownRemoteException,
    TResult Function()? noInternetException,
    TResult Function()? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (noInternetException != null) {
      return noInternetException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCachedException value) noCachedException,
    required TResult Function(UnknownLocalException value)
        unknownLocalException,
    required TResult Function(DeletingMyException value) deletingMyException,
    required TResult Function(UnknownRemoteException value)
        unknownRemoteException,
    required TResult Function(NoInternetException value) noInternetException,
    required TResult Function(ForbiddenMyException value) forbiddenMyException,
  }) {
    return noInternetException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoCachedException value)? noCachedException,
    TResult? Function(UnknownLocalException value)? unknownLocalException,
    TResult? Function(DeletingMyException value)? deletingMyException,
    TResult? Function(UnknownRemoteException value)? unknownRemoteException,
    TResult? Function(NoInternetException value)? noInternetException,
    TResult? Function(ForbiddenMyException value)? forbiddenMyException,
  }) {
    return noInternetException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCachedException value)? noCachedException,
    TResult Function(UnknownLocalException value)? unknownLocalException,
    TResult Function(DeletingMyException value)? deletingMyException,
    TResult Function(UnknownRemoteException value)? unknownRemoteException,
    TResult Function(NoInternetException value)? noInternetException,
    TResult Function(ForbiddenMyException value)? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (noInternetException != null) {
      return noInternetException(this);
    }
    return orElse();
  }
}

abstract class NoInternetException implements CustomException {
  const factory NoInternetException() = _$NoInternetException;
}

/// @nodoc
abstract class _$$ForbiddenMyExceptionCopyWith<$Res> {
  factory _$$ForbiddenMyExceptionCopyWith(_$ForbiddenMyException value,
          $Res Function(_$ForbiddenMyException) then) =
      __$$ForbiddenMyExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ForbiddenMyExceptionCopyWithImpl<$Res>
    extends _$MyExceptionCopyWithImpl<$Res, _$ForbiddenMyException>
    implements _$$ForbiddenMyExceptionCopyWith<$Res> {
  __$$ForbiddenMyExceptionCopyWithImpl(_$ForbiddenMyException _value,
      $Res Function(_$ForbiddenMyException) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ForbiddenMyException implements ForbiddenMyException {
  const _$ForbiddenMyException();

  @override
  String toString() {
    return 'MyException.forbiddenMyException()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ForbiddenMyException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCachedException,
    required TResult Function() unknownLocalException,
    required TResult Function() deletingMyException,
    required TResult Function() unknownRemoteException,
    required TResult Function() noInternetException,
    required TResult Function() forbiddenMyException,
  }) {
    return forbiddenMyException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noCachedException,
    TResult? Function()? unknownLocalException,
    TResult? Function()? deletingMyException,
    TResult? Function()? unknownRemoteException,
    TResult? Function()? noInternetException,
    TResult? Function()? forbiddenMyException,
  }) {
    return forbiddenMyException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCachedException,
    TResult Function()? unknownLocalException,
    TResult Function()? deletingMyException,
    TResult Function()? unknownRemoteException,
    TResult Function()? noInternetException,
    TResult Function()? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (forbiddenMyException != null) {
      return forbiddenMyException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCachedException value) noCachedException,
    required TResult Function(UnknownLocalException value)
        unknownLocalException,
    required TResult Function(DeletingMyException value) deletingMyException,
    required TResult Function(UnknownRemoteException value)
        unknownRemoteException,
    required TResult Function(NoInternetException value) noInternetException,
    required TResult Function(ForbiddenMyException value) forbiddenMyException,
  }) {
    return forbiddenMyException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoCachedException value)? noCachedException,
    TResult? Function(UnknownLocalException value)? unknownLocalException,
    TResult? Function(DeletingMyException value)? deletingMyException,
    TResult? Function(UnknownRemoteException value)? unknownRemoteException,
    TResult? Function(NoInternetException value)? noInternetException,
    TResult? Function(ForbiddenMyException value)? forbiddenMyException,
  }) {
    return forbiddenMyException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCachedException value)? noCachedException,
    TResult Function(UnknownLocalException value)? unknownLocalException,
    TResult Function(DeletingMyException value)? deletingMyException,
    TResult Function(UnknownRemoteException value)? unknownRemoteException,
    TResult Function(NoInternetException value)? noInternetException,
    TResult Function(ForbiddenMyException value)? forbiddenMyException,
    required TResult orElse(),
  }) {
    if (forbiddenMyException != null) {
      return forbiddenMyException(this);
    }
    return orElse();
  }
}

abstract class ForbiddenMyException implements CustomException {
  const factory ForbiddenMyException() = _$ForbiddenMyException;
}
